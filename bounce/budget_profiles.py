# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_budget_profiles.ipynb (unless otherwise specified).

__all__ = ['Profile', 'FlatProfile', 'StepProfile', 'LinearProfile', 'DelayedLinear']

# Cell
import numpy as np
import copy
import matplotlib.pyplot as plt

# Cell
class Profile:
    def __init__(self, iterations, min_params=50, max_params=3500):
        self.iterations = iterations
        self.min_params = min_params
        self.max_params = max_params
        self.generate_profile()

    def generate_profile(self):
        """This function sets up the parameters of the given profile"""
        pass

    def __call__(self,x):
        """Returns the maximum allowed number of parameters at a given point (or points) following the profile"""
        pass

    def plot_profile(self):
        """Plots the whole parameter profile"""
        x = np.arange(self.iterations)
        plt.plot(x, self.__call__(copy.deepcopy(x)))
        plt.grid()
        plt.xlabel("Iterations", fontsize=20)
        plt.ylabel("Maximum Parameters", fontsize=20)

# Cell
class FlatProfile(Profile):
    def __init__(self, max_params=3500):
        self.max_params = max_params

    def __call__(self, x):
        return self.max_params

    def plot_profile(self):
        print(f"Flat limit of {self.max_params}")

# Cell
class StepProfile(Profile):
    """Multi-step profile from minimum to maximum"""
    def __init__(self, iterations, steps, min_params=50, max_params=3500):
        self.steps = steps
        super().__init__(iterations, min_params, max_params)

    def generate_profile(self):
        self.idxs = np.linspace(0, self.iterations, num=self.steps+1, dtype=int)[:-1]
        self.amplitudes = np.append(0, np.linspace(self.min_params, self.max_params, num=self.steps, dtype=int))

    def __call__(self,x):
        # If no iteration is input, take the inner count
        return sum([(self.amplitudes[k+1]-self.amplitudes[k])*np.heaviside(x-xk,1) for k,xk in enumerate(self.idxs)])

# Cell
class LinearProfile(Profile):
    """Linear profile from the minimum of parameters to the maximum"""
    def generate_profile(self):
        self.slope = (self.max_params-self.min_params)/self.iterations

    def __call__(self,x):
        x = np.array(x)
        x[x > self.iterations] = self.iterations # Flatten the curve at the end
        return self.slope*x+self.min_params

# Cell
class DelayedLinear(Profile):
    """Linear profile strarting with a plateau at the beginning"""
    def __init__(self, iterations, x0, x1, min_params=50, max_params=3500):
        self.x0 = x0
        self.x1 = min(x1, iterations)
        super().__init__(iterations, min_params, max_params)

    def generate_profile(self):
        self.slope = (self.max_params-self.min_params)/(self.x1-self.x0)

    def __call__(self,x):
        x = np.array(x)
        x[x <= self.x0] = self.x0   # Flatten the curve at the beginning
        x[x >= self.x1] = self.x1   # Flatten the curve at the end
        return self.slope*(x-self.x0)+self.min_params